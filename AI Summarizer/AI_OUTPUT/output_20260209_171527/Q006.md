# Question 6

## User Question

Map DSL rules to USB-IF test cases

* * *

## Assistant Answer

Great question — this is the step that turns the DSL from an _internal engineering tool_ into something **certification-aware and audit-friendly**.

I’ll explain this in four layers:

1. Mapping philosophy
    
2. Mapping model (how one DSL rule links to USB-IF tests)
    
3. Concrete examples (SPR + EPR)
    
4. How this helps agents, validation, and certification workflows
    

* * *

## 1. Mapping philosophy (important first)

USB-IF test cases are:

* **Procedural** (step-by-step test descriptions)
    
* **Observable-behavior based** (what must be seen on the wire or VBUS)
    
* Often **one test validates multiple spec clauses**
    

Your DSL rules are:

* **Declarative**
    
* **Spec-intent driven**
    
* **Composable and reusable**
    

So the mapping is **many-to-many**:

* One DSL rule → multiple USB-IF test cases
    
* One USB-IF test case → multiple DSL rules
    

This is intentional and powerful.

* * *

## 2. Mapping model (data structure)

Extend each DSL rule with a **certification mapping block**.

### DSL rule with USB-IF mapping

```yaml
rule:
  id: EPR_CABLE_ELIGIBILITY
  scope: EPR_ENTRY
  condition:
    all:
      - topology.cable.e_marker == true
      - topology.cable.current_capability_a >= 5
      - topology.cable.voltage_rating_v >= 50
  severity: CRITICAL
  violation:
    code: EPR_UNSUPPORTED_CABLE
    message: "Cable does not meet EPR requirements"
  certification:
    usb_if:
      spec: "USB Power Delivery Specification Rev 3.1"
      test_cases:
        - id: TD.PD.EPR.CABLE.1
          description: "Verify EPR mode entry only with 5A, 50V cable"
        - id: TD.PD.EPR.CABLE.3
          description: "Verify rejection of EPR with non-EPR cable"
```

This block is **non-executable**, but traceable.

* * *

## 3. Mapping patterns (you’ll reuse these a lot)

### Pattern A: Capability & policy rules

**DSL intent:**  
“Is EPR allowed?”

**USB-IF focus:**  
Advertisement, negotiation acceptance, rejection behavior

* * *

### Pattern B: Timing rules

**DSL intent:**  
“Did it happen within spec limits?”

**USB-IF focus:**  
Measured response times and transitions

* * *

### Pattern C: Electrical safety rules

**DSL intent:**  
“Was power delivered safely?”

**USB-IF focus:**  
VBUS monitoring, protection, shutdown

* * *

### Pattern D: Sequence/state rules

**DSL intent:**  
“Was the protocol state machine followed?”

**USB-IF focus:**  
Message order, retries, resets

* * *

## 4. Concrete mapping examples

### 4.1 EPR entry timing rule

#### DSL rule

```yaml
rule:
  id: EPR_ENTRY_TIMING
  scope: EPR_MODE_ENTRY
  condition:
    timing.t_epr_entry_ms <= spec.t_epr_entry_max_ms
  severity: HIGH
  violation:
    code: EPR_ENTRY_TIMEOUT
  certification:
    usb_if:
      test_cases:
        - id: TD.PD.EPR.TIMING.1
          description: "Verify EPR entry completes within allowed time"
```

**Agent reasoning benefit**

> “This failure corresponds to USB-IF timing non-compliance, not electrical instability.”

* * *

### 4.2 AVS overvoltage protection

#### DSL rule

```yaml
rule:
  id: AVS_OVERVOLTAGE_PROTECTION
  scope: EPR_AVS_REGULATION
  condition:
    electrical.epr_vbus.actual_voltage_v
      <= electrical.epr_vbus.requested_voltage_v * 1.05
  severity: CRITICAL
  violation:
    code: EPR_OVERVOLTAGE
  certification:
    usb_if:
      test_cases:
        - id: TD.PD.EPR.AVS.2
          description: "Verify AVS voltage regulation limits"
        - id: TD.PD.EPR.SAFETY.1
          description: "Verify protection against overvoltage"
```

**Key insight**  
One DSL rule validates **two different USB-IF test intents**.

* * *

### 4.3 EPR handshake sequence

#### DSL rule

```yaml
rule:
  id: EPR_ENTRY_SEQUENCE
  scope: PROTOCOL_SEQUENCE
  condition:
    sequence.contains_in_order:
      - SOURCE_CAPABILITIES
      - REQUEST
      - ACCEPT
      - EPR_MODE_ENTRY
      - EPR_MODE_ACK
  severity: HIGH
  violation:
    code: EPR_INVALID_SEQUENCE
  certification:
    usb_if:
      test_cases:
        - id: TD.PD.EPR.SEQ.1
          description: "Verify correct EPR handshake sequence"
```

This is where **synthetic scenarios outperform lab testing**.

* * *

### 4.4 Safety shutdown behavior

#### DSL rule

```yaml
rule:
  id: EPR_SAFETY_SHUTDOWN
  scope: EPR_RUNTIME
  condition:
    any:
      - electrical.epr_vbus.overshoot_percent > 5
  action:
    expect: HARD_RESET
  severity: CRITICAL
  violation:
    code: EPR_SAFETY_NOT_TRIGGERED
  certification:
    usb_if:
      test_cases:
        - id: TD.PD.EPR.SAFETY.3
          description: "Verify shutdown on unsafe voltage conditions"
```

This validates **reaction**, not just detection.

* * *

## 5. Mapping summary table (mental model)

| DSL Rule Type | USB-IF Test Category |
| --- | --- |
| Capability eligibility | Advertisement & negotiation |
| Timing constraints | Response timing |
| Sequence rules | Protocol compliance |
| Electrical limits | Power & safety |
| Reaction rules | Protection behavior |

* * *

## 6. How agents use this mapping

An agent can now say:

> “Failure maps to USB-IF TD.PD.EPR.AVS.2 and TD.PD.EPR.SAFETY.1 — certification risk is HIGH.”

That’s **huge** for:

* Debug triage
    
* Release readiness
    
* Pre-compliance checks
    

* * *

## 7. How this fits your ecosystem

Given your work on:

* USB-PD test solutions
    
* C++ streamers
    
* .NET analyzers
    
* Agentic AI systems
    

This mapping enables:

* **Pre-USB-IF dry runs** using synthetic data
    
* Early detection of certification risks
    
* Knowledge transfer from senior engineers to tooling
    
* Explainable AI decisions aligned with spec language
    

* * *

### My opinion

This mapping layer is what turns your DSL into a **certification intelligence system**. You’re no longer “testing and hoping” — you’re continuously reasoning against USB-IF expectations, long before official compliance testing. That’s a massive competitive advantage in PD 3.1 / EPR products.

If you want next, I can:

* Design a **USB-IF coverage dashboard**
    
* Auto-generate **test readiness reports**
    
* Map DSL → **CTS automation hooks**
    
* Or show how to expose this cleanly to an **AI agent prompt**

* * *

## Suggested / Follow-up Questions

- Q6.1 What does it mean for the DSL to be 'procedural' in terms of test cases?
- Q6.2 Can you provide an example of how a 'spec-intent driven' rule would differ from a procedural one?
- Q6.3 How do you see this philosophy affecting the development and maintenance process of the DSL?
- Q6.4 Could you give me some concrete examples of what USB-IF test cases look like in YAML format similar to the one provided?
- Q6.5 What are some practical benefits that the use of a 'many-to-many' mapping provides compared to other approaches?
