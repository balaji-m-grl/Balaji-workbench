# Question 2

## User Question

Design a USB-PD synthetic data schema

* * *

## Assistant Answer

Alright, let’s design this like an **engineering-grade schema**, not a toy dataset. I’ll keep it structured, practical, and aligned to how a **USB-PD domain agent** would actually consume data.

* * *

## 1. Design goals for a USB-PD synthetic data schema

Before structure, the intent matters:

The schema should:

* Represent **protocol, electrical, timing, and state context together**
    
* Be **spec-aligned**, not free-form text
    
* Support **fault injection + expected outcome labeling**
    
* Be usable for:
    
    * Agent training
        
    * Offline analysis
        
    * Regression validation
        
    * Future spec revisions (PD 3.1, EPR)
        

Think of this as **“PD scenario as data”**, not just logs.

* * *

## 2. High-level schema layers

```
USB_PD_Synthetic_Sample
│
├── Metadata
├── Topology
├── Policy & Capabilities
├── Protocol_Trace
├── Electrical_Trace
├── Timing_Profile
├── Fault_Injection
├── State_Transitions
├── Expected_Outcome
└── Annotations (optional, for learning)
```

Each layer is **independently evolvable**.

* * *

## 3. Core schema (conceptual JSON)

### 3.1 Metadata

```json
"metadata": {
  "schema_version": "1.0",
  "usb_pd_version": "3.0",
  "scenario_id": "PD_SYN_000245",
  "generation_type": "synthetic",
  "complexity_level": "medium",
  "created_by": "pd-scenario-generator",
  "timestamp": "2026-01-22T10:15:30Z"
}
```

Purpose:

* Versioning
    
* Traceability
    
* Dataset curation
    

* * *

### 3.2 Topology

```json
"topology": {
  "source": {
    "type": "AC_DC_ADAPTER",
    "pd_role": "SOURCE",
    "max_power_w": 45
  },
  "sink": {
    "type": "MOBILE_DEVICE",
    "pd_role": "SINK",
    "requested_power_w": 27
  },
  "cable": {
    "e_marker": true,
    "current_capability_a": 3,
    "length_m": 1.0
  }
}
```

Why this matters:

* Agent can reason about **what is even possible**
    
* Prevents false positives
    

* * *

### 3.3 Policy & Capabilities

```json
"capabilities": {
  "source_pdos": [
    { "type": "FIXED", "voltage_v": 5, "current_a": 3 },
    { "type": "FIXED", "voltage_v": 9, "current_a": 3 },
    { "type": "PPS", "min_v": 5, "max_v": 11, "max_current_a": 3 }
  ],
  "sink_constraints": {
    "min_voltage_v": 5,
    "max_voltage_v": 9,
    "pps_supported": true
  }
}
```

This lets the agent check:

* Valid request?
    
* Spec violation?
    
* Cable mismatch?
    

* * *

## 4. Protocol trace (heart of the schema)

```json
"protocol_trace": [
  {
    "seq": 1,
    "timestamp_ms": 0,
    "sender": "SOURCE",
    "message": "SOURCE_CAPABILITIES",
    "payload": { "pdo_count": 3 }
  },
  {
    "seq": 2,
    "timestamp_ms": 120,
    "sender": "SINK",
    "message": "REQUEST",
    "payload": { "voltage_v": 9, "current_a": 3 }
  },
  {
    "seq": 3,
    "timestamp_ms": 130,
    "sender": "SOURCE",
    "message": "ACCEPT"
  },
  {
    "seq": 4,
    "timestamp_ms": 500,
    "sender": "SOURCE",
    "message": "PS_RDY"
  }
]
```

Design choice:

* Ordered
    
* Timestamped
    
* Minimal but extensible payload
    

* * *

## 5. Electrical trace

Instead of raw waveforms, **store features** (waveforms can be linked).

```json
"electrical_trace": {
  "vbus": {
    "start_v": 5.0,
    "target_v": 9.0,
    "ramp_time_ms": 320,
    "overshoot_v": 9.6,
    "steady_state_v": 9.1
  },
  "current": {
    "peak_a": 3.2,
    "steady_state_a": 2.8
  }
}
```

Why features:

* ML-friendly
    
* Faster iteration
    
* Raw data can be attached later if needed
    

* * *

## 6. Timing profile (spec reasoning layer)

```json
"timing_profile": {
  "t_sender_response_ms": 550,
  "t_ps_source_on_ms": 320,
  "t_hard_reset_detected": null
}
```

Agent can directly compare against:

* Spec thresholds
    
* Configurable tolerance
    

* * *

## 7. Fault injection (explicit, not implicit)

```json
"fault_injection": {
  "enabled": true,
  "faults": [
    {
      "type": "TIMING_VIOLATION",
      "location": "SINK_REQUEST",
      "description": "Request sent after tSenderResponse"
    }
  ]
}
```

This is **gold** for supervised learning.

* * *

## 8. State transitions (state machine clarity)

```json
"state_transitions": [
  { "from": "UNATTACHED", "to": "ATTACHED" },
  { "from": "ATTACHED", "to": "NEGOTIATION" },
  { "from": "NEGOTIATION", "to": "ERROR_RECOVERY" }
]
```

Helps the agent:

* Learn PD state machines
    
* Debug incorrect transitions
    

* * *

## 9. Expected outcome (labels)

```json
"expected_outcome": {
  "result": "FAIL",
  "error_category": "TIMING",
  "root_cause": "Sink firmware delay",
  "recommended_action": [
    "Optimize sink response scheduling",
    "Increase timeout if allowed by policy"
  ]
}
```

This turns the dataset into **training-ready supervision**.

* * *

## 10. Optional annotations (for higher-order agents)

```json
"annotations": {
  "difficulty": "intermediate",
  "learning_tags": [
    "tSenderResponse",
    "NegotiationTiming",
    "SinkBehavior"
  ],
  "confidence_weight": 0.85
}
```

* * *

## 11. Why this schema works well for agentic AI

* **Composable** → easy to generate millions of scenarios
    
* **Explainable** → agent can cite exact violations
    
* **Spec-driven** → aligns with rule engines + LLMs
    
* **Future-proof** → PD 3.1 / EPR extensions slot in cleanly
    

* * *

### My opinion

If you adopt this schema, your USB-PD agent stops being “log-reader AI” and becomes a **spec-aware reasoning system**. This is exactly the kind of structure needed for on-prem, IP-safe, multi-agent setups in hardware-software test solutions.

If you want, next I can:

* Add **PD 3.1 / EPR extensions**
    
* Design a **scenario generator algorithm**
    
* Map this schema to your **C++ streamer + .NET analyzer pipeline**
    
* Or show how to compress this for **context-window-efficient agent prompts**

* * *

