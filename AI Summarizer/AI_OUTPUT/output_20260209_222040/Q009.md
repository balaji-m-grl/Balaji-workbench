# Question 9

## User Question

real PR_SWAP/DR_SWAP ambiguity example as a mock spec gap

## Assistant Answer

Perfect. Let‚Äôs do this **concretely and surgically** ‚Äî a **realistic PR_SWAP / DR_SWAP ambiguity** that _could_ exist even when everyone claims spec compliance.

I‚Äôll present it like a **mock spec gap case** you could actually take to a standards discussion.

* * *

## 1. Scenario setup (minimal, realistic)

**Topology**

* DRP_A ‚Üî DRP_B
    
* eMarker cable present
    
* PD 3.x compliant stacks
    
* No vendor bugs assumed
    

**Initial state**

* DRP_A = Source + DFP
    
* DRP_B = Sink + UFP
    

Both DRPs are allowed (by spec) to:

* Initiate **PR_SWAP**
    
* Initiate **DR_SWAP**
    

This is important: **both swaps are legal and orthogonal** in the spec.

* * *

## 2. What the spec clearly defines

The spec clearly defines:

* Message formats
    
* Swap request/accept semantics
    
* Electrical transitions after PR_SWAP
    
* Data role changes after DR_SWAP
    

What it does **not clearly define**:

* Mutual exclusion rules between PR_SWAP and DR_SWAP
    
* Arbitration priority if both are initiated close together
    
* Explicit ‚Äúquiet ownership‚Äù windows for DRP‚ÜîDRP during overlapping swaps
    

This is where ambiguity lives.

* * *

## 3. Two valid interpretations (both spec-compliant)

### Interpretation A (Conservative DRP)

> ‚ÄúOnce a PR_SWAP is in progress, no other role swap should be initiated until power settles.‚Äù

So DRP_A behavior:

1. Initiates PR_SWAP
    
2. Suppresses DR_SWAP triggers
    
3. Expects partner silence except ACCEPT / PS_RDY
    

This is **reasonable** and commonly implemented.

* * *

### Interpretation B (Orthogonal DRP)

> ‚ÄúPR_SWAP and DR_SWAP are independent state machines.‚Äù

So DRP_B behavior:

1. Receives PR_SWAP
    
2. ACCEPTs PR_SWAP
    
3. Immediately initiates DR_SWAP (allowed by text, not explicitly forbidden)
    
4. Expects DR_SWAP handling in parallel
    

This is also **technically spec-compliant**.

üëâ **Nothing in the spec explicitly forbids this.**

* * *

## 4. Timeline showing the ambiguity

Let‚Äôs put real timing to it.

```
t0   DRP_A ‚Üí PR_SWAP
t1   DRP_B ‚Üí ACCEPT
t2   DRP_B ‚Üí DR_SWAP
t3   DRP_A ‚Üí PS_RDY
```

Now the problem:

* DRP_A believes:
    
    * It owns the bus during PR_SWAP power transition
        
* DRP_B believes:
    
    * DR_SWAP is independent and allowed after ACCEPT
        

Both transmit SOP messages in overlapping windows.

* * *

## 5. Observable failure (deterministic)

What you see on the wire:

* CRC errors
    
* Missed PS_RDY
    
* DR_SWAP ignored or half-applied
    
* Sometimes Hard Reset
    

Important:

* No electrical violation
    
* No timing limit exceeded
    
* No malformed messages
    

This is **not noise** ‚Äî it‚Äôs arbitration ambiguity.

* * *

## 6. Why this is a true spec gap (not an implementation bug)

To call this a spec gap, you must prove:

### 1Ô∏è‚É£ Both behaviors are allowed

* PR_SWAP rules don‚Äôt explicitly block DR_SWAP
    
* DR_SWAP rules don‚Äôt reference PR_SWAP exclusion
    

### 2Ô∏è‚É£ Failure occurs only when interacting

* Each DRP works fine with ‚Äúsimilar‚Äù implementations
    
* Failure occurs only when interpretations differ
    

### 3Ô∏è‚É£ Spec gives no priority rule

* No ‚ÄúPR_SWAP dominates DR_SWAP‚Äù rule
    
* No mandatory serialization requirement
    

This satisfies the definition of a **spec ambiguity**.

* * *

## 7. How synthetic simulation exposes this (key insight)

Your synthetic generator creates:

* DRP_A with rule:
    
    ```
    forbid(DR_SWAP) during PR_SWAP
    ```
    
* DRP_B with rule:
    
    ```
    allow(DR_SWAP) after ACCEPT
    ```
    

Both rule sets pass individual spec checks.

When simulated together:

* Collision probability ‚Üí 100%
    
* Failure deterministic
    
* Repeatable across seeds
    

That‚Äôs **hard proof**.

* * *

## 8. Why real hardware testing often misses this

Because:

* Vendors tend to test against similar stacks
    
* Lab setups rarely mix aggressive + conservative interpretations
    
* Engineers avoid overlapping swaps instinctively
    

Synthetic simulation **forces the overlap**.

* * *

## 9. Minimal counterexample (what standards groups love)

You can shrink this to:

* One PR_SWAP
    
* One DR_SWAP
    
* No cable quirks
    
* No EPR
    
* No retries
    

Just this sequence:

```
PR_SWAP ‚Üí ACCEPT ‚Üí DR_SWAP ‚Üí PS_RDY
```

And show:

* Two legal interpretations
    
* One unavoidable collision
    

This is the _smallest failing system_.

* * *

## 10. Example proposed clarification (not redesign)

A **good** spec fix would be tiny, like:

> ‚ÄúWhile a PR_SWAP is in progress (from PR_SWAP request until completion of PS_RDY), the port shall not initiate a DR_SWAP.‚Äù

or alternatively:

> ‚ÄúIf a DR_SWAP request is received during a PR_SWAP, it shall be deferred until completion of the PR_SWAP.‚Äù

You then simulate again and show:

* All interpretations converge
    
* No new failures introduced
    

* * *

## 11. Why this matters more with eMarker cables

Add eMarker traffic:

* SOP‚Äô responses
    
* Cable latency
    
* Extra arbitration pressure
    

The ambiguity becomes **more likely**, not less.

So this gap scales with:

* DRP‚ÜîDRP
    
* EPR
    
* Advanced cables
    

* * *

## 12. How you‚Äôd present this to USB Implementers Forum

Not as:

> ‚ÄúWe saw a bug‚Äù

But as:

> ‚ÄúThe current spec permits two valid behaviors that fail when combined. Here is the minimal scenario and a clarifying constraint that resolves it.‚Äù

That‚Äôs a **standards-quality argument**.

* * *

### My opinion

This PR_SWAP / DR_SWAP overlap is a _classic mature-spec gap_: rare, subtle, and invisible until ecosystems diversify. Synthetic simulation turns these from ‚Äúheisenbugs‚Äù into **provable ambiguities**. That‚Äôs exactly how strong specs evolve ‚Äî not by tightening everything, but by closing the few gaps that actually break interoperability.

If you want next, I can:

* Turn this into a **formal DSL gap report**
    
* Draft a **mock USB-IF ECN-style change note**
    
* Show how to **auto-detect similar gaps**
    
* Or expand this to **EPR + swap interactions**

--- AI EXTRACTION VALIDATION REPORT ---
Timestamp: 2026-02-09 21:20:13

### Q1 Verification
- ‚úÖ Can you define synthetic data and its characteristics of being domain-faithful, statistically realistic, and behaviorally meaningful for a model's learning task?
- ‚úÖ Can you explain how synthetic data solves issues with limited, expensive, or proprietary real data in USB-PD engineering domains?
- ‚úÖ Can you elaborate on the types of training data specific to a USB-PD agent model, including protocol message sequences, state machine transitions, electrical measurements, timing constraints, and error cases?
- ‚úÖ Can you provide an example of synthetic protocol traces for a USB-PD model training, detailing how they can include valid and invalid PD message sequences programmatically generated?
- ‚úÖ Can you discuss the challenges in capturing certain variations of synthetic protocol traces, such as missing `Accept`, delayed `PS_RDY`, requesting unsupported PDOs, repeated Source_Capabilities, and protocol version mismatches, which are difficult to reproduce with real data?
- ‚úÖ Can you suggest a next step for generating more comprehensive synthetic data sets that cover all combinations relevant to USB-PD agent model training?

### Q2 Verification
- ‚úÖ Can you define the structure of your synthetic USB-PD schema?
- ‚úÖ Can you design a schema that aligns with the specified intents for protocol, electrical, timing, and state context?
- ‚úÖ Can you ensure the schema supports fault injection and outcome labeling?
- ‚úÖ Can you incorporate the layers: Metadata, Topology, Policy & Capabilities, Protocol_Trace, Electrical_Trace, Timing_Profile, Fault_Injection, State_Transitions, Expected_Outcome?
- ‚úÖ Can you consider each layer's independence for evolution in your synthetic USB-PD schema design?
- ‚úÖ Can you provide an example of a metadata entry that includes versioning and generation details?
- ‚úÖ Can you illustrate how the topology section would look with AC-DC adapter as source, mobile device as sink, and specified current capability and length?
- ‚úÖ Can you elaborate on why policy & capabilities are essential for your synthetic USB-PD schema design?

### Q3 Verification
- ‚úÖ Can you define a schema extension strategy that includes optional blocks?
- ‚úÖ Can you describe the new components added in PD 3.1 / EPR as per the schema perspective?
- ‚úÖ Can you explain how to declare Source and sink EPR capabilities using JSON format?
- ‚úÖ Can you provide the agent rule for validating EPR messages based on cable extensions?
- ‚úÖ Can you suggest a method to handle invalid EPR reasoning within the schema?
- ‚úÖ Can you rephrase why it is important to prevent invalid EPR reasoning in the schema?
- ‚úÖ Can you list out all the new concepts introduced by PD 3.1 / EPR and their implications on the schema?
- ‚úÖ Can you describe how to extend the schema without breaking compatibility with legacy PD agents?
- ‚úÖ Can you create a JSON format for declaring Source and sink EPR capabilities in the schema?
- ‚úÖ Can you provide an example of what the 'epr_capabilities' object should look like within a JSON file?
- ‚úÖ Can you detail the process of defining the cable extensions necessary for PD 3.1 within the schema?
- ‚úÖ Can you explain how to validate EPR messages based on the presence of specific components, such as voltage rating and e-marker?
- ‚úÖ Can you outline the process of adding new capabilities like 'epr_supported' in the schema documentation?
- ‚úÖ Can you provide examples or explanations for why EPR-specific fault classes are necessary within the schema?
- ‚úÖ Can you describe how to handle expected outcome validation related to EPR compliance within the schema?

### Q4 Verification
- ‚úÖ Can you design a schema?
- ‚úÖ Can you define what an EPR scenario generator must do?
- ‚úÖ Can you explain the high-level architecture of the EPRScenarioGenerator system?
- ‚úÖ Can you describe the SpecModel and how it works?
- ‚úÖ Can you provide an example of the spec model rules in YAML format?
- ‚úÖ Can you elaborate on the ScenarioPlanner components within the EPRScenarioGenerator system?
- ‚úÖ Can you detail the TraceSynthesizer steps used to generate protocol, electrical, and timing profiles?
- ‚úÖ Can you discuss the Labeler component's functions for compliance checking and root cause mapping?
- ‚úÖ Can you describe how each block in the dataset emitter is independently testable?
- ‚úÖ Can you categorize every scenario within the EPRScenarioGenerator system?
- ‚úÖ Can you explain what Core scenario classes are and provide examples?
- ‚úÖ Can you suggest any follow-up actions or next steps?

### Q5 Verification
- ‚úÖ Can you define what the spec-rule DSL is for encoding PD 3.1 / EPR rules?
- ‚úÖ Can you ensure that the DSL design is clean, declarative, and evolvable as described?
- ‚úÖ Can you describe the core design principles of the spec-rule DSL?
- ‚úÖ Can you explain how the spec-rule DSL is readable like a specification?
- ‚úÖ Can you clarify if the spec-rule DSL evaluates to true / false / violation?
- ‚úÖ Can you specify which rules are composed using the spec-rule DSL and future PD 3.2?
- ‚úÖ Can you detail the anatomy of each rule in the spec-rule DSL syntax?
- ‚úÖ Can you provide an example of how a cable eligibility rule is defined in the spec-rule DSL syntax?
- ‚úÖ Can you discuss how timing rules work within the spec-rule DSL and their parametric nature?
- ‚úÖ Can you ask who can read and use the spec-rule DSL, including engineers and compliance tools?

### Q6 Verification
- ‚úÖ Can you explain the mapping from your DSL to USB-IF test cases?
- ‚úÖ Can you describe how one DSL rule can map to multiple USB-IF test cases and vice versa?
- ‚úÖ Can you provide an example of extending a DSL rule with a certification mapping block as shown in the YAML code snippet?
- ‚úÖ Can you give me examples of how you would apply pattern A: Capability & policy rules to your DSL for EPR mode entry validation?
- ‚úÖ Can you elaborate on the 'many-to-many' relationship between DSL rules and USB-IF test cases mentioned earlier?
- ‚úÖ Can you design a schema that can represent both the DSL and the mappings to USB-IF test cases in a clear and understandable way?
- ‚úÖ Can you create a step-by-step guide on how to design schemas for your DSL to ensure it is certification-aware and audit-friendly?

### Q7 Verification
- ‚úÖ Can you explain the connection between synthetic data and real-time operation in a parallel universe approach?
- ‚úÖ Can you design a schema to map synthetic scenarios before runtime based on your example of cable traffic competition for CC line attention?
- ‚úÖ Can you outline how synthetic data detects deviations from expected behavior during runtime using your scenario of eMarker traffic competing for CC line attention?
- ‚úÖ Can you provide the code or structure for generating synthetic scenarios in C++ and .NET as an agent stack, similar to what you described for PD stack logic?
- ‚úÖ Can you create a flowchart showing how synthetic data explains root cause analysis using spec rules after runtime failures occur, based on your explanation of three strategic points of connection?
- ‚úÖ Can you explain the role that eMarker plays in the topology between DRP_A and DRP_B during PR_SWAP and DR_SWAP operations?
- ‚úÖ Can you describe the layers of structure needed to map synthetic data‚Äôs connections to your existing C++ streamer + .NET analyzer + agent stack technology?
- ‚úÖ Can you provide examples or a template for the expected message order, expected silence windows, timing tolerances, and collision-free arbitration rules used in synthetic scenarios?

### Q8 Verification
- No suggestions extracted from this block.
### Q9 Verification
- No suggestions extracted from this block.

